/**
 * Cubicación Generator
 *
 * Automatically generates quantity takeoff (cubicación) from infrastructure entities
 * Maps drawn elements to SERVIU itemizado codes with calculated quantities
 */

import type {
  CubicacionItem,
  Cubicacion,
  CubicacionSubtotal,
  CubicacionGeneratorConfig,
  CubicacionCategory,
  MeasurementUnit,
} from './types';
import { DEFAULT_GENERATOR_CONFIG, CATEGORY_LABELS } from './types';
import {
  SERVIU_ITEMS,
  getServiuItem,
  getPipeItem,
  getManholeItem,
  getExcavationItem,
  getRegionalPriceFactor,
} from './serviu-itemizado';
import type {
  AnyInfrastructureEntity,
  WaterPipeEntity,
  SewerPipeEntity,
  StormCollectorEntity,
  ManholeEntity,
  StormInletEntity,
  HouseConnectionEntity,
  WaterValveEntity,
  HydrantEntity,
} from '@/types/infrastructure-entities';

// ============================================================================
// Types
// ============================================================================

interface GeneratorContext {
  config: CubicacionGeneratorConfig;
  region?: string;
  priceFactor: number;
  terrainType: 1 | 2 | 3;
}

interface QuantityResult {
  serviuCode: string;
  quantity: number;
  unit: MeasurementUnit;
  category: CubicacionCategory;
  description: string;
  sourceEntityIds: string[];
  calculationDetails: string;
}

// ============================================================================
// Main Generator Function
// ============================================================================

/**
 * Generate cubicación from infrastructure entities
 */
export function generateCubicacion(
  entities: Map<string, AnyInfrastructureEntity> | AnyInfrastructureEntity[],
  projectId: string,
  options: {
    name?: string;
    config?: Partial<CubicacionGeneratorConfig>;
    region?: string;
    terrainType?: 1 | 2 | 3;
  } = {}
): Cubicacion {
  const entityArray = entities instanceof Map ? Array.from(entities.values()) : entities;

  const config: CubicacionGeneratorConfig = {
    ...DEFAULT_GENERATOR_CONFIG,
    ...options.config,
  };

  const context: GeneratorContext = {
    config,
    region: options.region || 'Metropolitana',
    priceFactor: getRegionalPriceFactor(options.region || 'Metropolitana'),
    terrainType: options.terrainType || 1,
  };

  // Generate quantities from each entity type
  const quantities: QuantityResult[] = [];

  // Process each entity
  for (const entity of entityArray) {
    const entityQuantities = generateEntityQuantities(entity, context);
    quantities.push(...entityQuantities);
  }

  // Merge duplicate items (same SERVIU code)
  const mergedItems = mergeQuantities(quantities, context);

  // Calculate totals
  const items: CubicacionItem[] = mergedItems.map((q, index) => {
    const serviuItem = getServiuItem(q.serviuCode);
    const unitPrice = Math.round((serviuItem?.basePrice || 0) * context.priceFactor);
    const quantity = config.roundQuantities
      ? roundQuantity(q.quantity, config.quantityDecimals)
      : q.quantity;
    const totalPrice = Math.round(quantity * unitPrice);

    return {
      id: `cub_item_${Date.now()}_${index}`,
      serviuCode: q.serviuCode,
      description: q.description,
      shortDescription: serviuItem?.shortDescription,
      category: q.category,
      unit: q.unit,
      quantity,
      unitPrice,
      totalPrice,
      sourceEntityIds: q.sourceEntityIds,
      calculationDetails: q.calculationDetails,
      isManualOverride: false,
      autoCalculated: true,
      lastUpdated: new Date().toISOString(),
    };
  });

  // Calculate subtotals by category
  const subtotals = calculateSubtotals(items);

  // Calculate grand total
  const grandTotal = items.reduce((sum, item) => sum + item.totalPrice, 0);

  // Apply contingency if configured
  const finalTotal = config.applyContingency
    ? Math.round(grandTotal * (1 + config.contingencyPercent / 100))
    : grandTotal;

  const now = new Date().toISOString();

  return {
    id: `cub_${Date.now()}`,
    projectId,
    name: options.name || `Cubicación ${new Date().toLocaleDateString('es-CL')}`,
    version: 1,
    status: 'draft',
    items,
    subtotals,
    grandTotal: finalTotal,
    priceDate: now.split('T')[0],
    priceSource: `SERVIU ${options.region || 'RM'} 2024`,
    currency: 'CLP',
    createdAt: now,
    updatedAt: now,
    lastAutoGenerated: now,
    autoGenerationEnabled: true,
  };
}

// ============================================================================
// Entity-Specific Quantity Generators
// ============================================================================

function generateEntityQuantities(
  entity: AnyInfrastructureEntity,
  context: GeneratorContext
): QuantityResult[] {
  switch (entity.infrastructureType) {
    case 'water_pipe':
      return generateWaterPipeQuantities(entity as WaterPipeEntity, context);
    case 'sewer_pipe':
      return generateSewerPipeQuantities(entity as SewerPipeEntity, context);
    case 'storm_collector':
      return generateStormCollectorQuantities(entity as StormCollectorEntity, context);
    case 'manhole':
      return generateManholeQuantities(entity as ManholeEntity, context);
    case 'storm_inlet':
      return generateStormInletQuantities(entity as StormInletEntity, context);
    case 'house_connection':
      return generateHouseConnectionQuantities(entity as HouseConnectionEntity, context);
    case 'water_valve':
      return generateWaterValveQuantities(entity as WaterValveEntity, context);
    case 'hydrant':
      return generateHydrantQuantities(entity as HydrantEntity, context);
    default:
      return [];
  }
}

// --- Water Pipe ---
function generateWaterPipeQuantities(
  pipe: WaterPipeEntity,
  context: GeneratorContext
): QuantityResult[] {
  const results: QuantityResult[] = [];
  const { config } = context;

  const length = pipe.length;
  const diameterMm = pipe.diameter;
  const diameterM = diameterMm / 1000;
  const depth = pipe.burialDepth || config.defaultOvertapado + diameterM;

  // 1. Pipe itself
  const pipeType = pipe.material === 'hdpe' ? 'water_hdpe' : 'water_pvc';
  const pipeItem = getPipeItem(diameterMm, pipeType);
  if (pipeItem) {
    results.push({
      serviuCode: pipeItem.code,
      quantity: length,
      unit: 'm',
      category: 'tuberia',
      description: pipeItem.description,
      sourceEntityIds: [pipe.id],
      calculationDetails: `Longitud tubería: ${length.toFixed(2)}m`,
    });
  }

  // 2. Excavation
  const trenchWidth = Math.max(
    config.minTrenchWidth,
    diameterM * config.defaultTrenchWidthFactor
  );
  const excavationVolume = length * trenchWidth * depth;
  const excItem = getExcavationItem(context.terrainType);
  if (excItem) {
    results.push({
      serviuCode: excItem.code,
      quantity: excavationVolume,
      unit: 'm3',
      category: 'excavacion',
      description: excItem.description,
      sourceEntityIds: [pipe.id],
      calculationDetails: `L=${length.toFixed(2)}m × A=${trenchWidth.toFixed(2)}m × H=${depth.toFixed(2)}m`,
    });
  }

  // 3. Bedding
  const beddingWidth = Math.max(trenchWidth * 0.8, diameterM + 0.3);
  const beddingVolume = length * beddingWidth * config.defaultBeddingThickness;
  results.push({
    serviuCode: '220.2', // Cama arena 15cm
    quantity: beddingVolume,
    unit: 'm3',
    category: 'cama',
    description: 'Cama de arena para tuberías, e=0.15m',
    sourceEntityIds: [pipe.id],
    calculationDetails: `L=${length.toFixed(2)}m × A=${beddingWidth.toFixed(2)}m × e=${config.defaultBeddingThickness}m`,
  });

  // 4. Backfill
  const backfillVolume = excavationVolume - beddingVolume - length * Math.PI * Math.pow(diameterM / 2, 2);
  if (backfillVolume > 0) {
    results.push({
      serviuCode: '210.1', // Relleno seleccionado
      quantity: backfillVolume,
      unit: 'm3',
      category: 'relleno',
      description: 'Relleno compactado con material seleccionado de la excavación',
      sourceEntityIds: [pipe.id],
      calculationDetails: `Vol. excavación - cama - tubería = ${backfillVolume.toFixed(2)}m³`,
    });
  }

  // 5. Excess material removal
  const excessVolume = length * Math.PI * Math.pow(diameterM / 2, 2) + beddingVolume * 0.1;
  results.push({
    serviuCode: '203.1', // Retiro excedentes
    quantity: excessVolume,
    unit: 'm3',
    category: 'excavacion',
    description: 'Retiro y transporte de excedentes a botadero autorizado',
    sourceEntityIds: [pipe.id],
    calculationDetails: `Volumen tubería + esponjamiento`,
  });

  return results;
}

// --- Sewer Pipe ---
function generateSewerPipeQuantities(
  pipe: SewerPipeEntity,
  context: GeneratorContext
): QuantityResult[] {
  const results: QuantityResult[] = [];
  const { config } = context;

  const length = pipe.length;
  const diameterMm = pipe.diameter;
  const diameterM = diameterMm / 1000;

  // Calculate average depth from inverts
  const avgDepth = ((pipe.invertStart || 0) + (pipe.invertEnd || 0)) / 2 || 2.0;

  // 1. Pipe
  const pipeItem = getPipeItem(diameterMm, 'sewer');
  if (pipeItem) {
    results.push({
      serviuCode: pipeItem.code,
      quantity: length,
      unit: 'm',
      category: 'tuberia',
      description: pipeItem.description,
      sourceEntityIds: [pipe.id],
      calculationDetails: `Longitud tubería: ${length.toFixed(2)}m`,
    });
  }

  // 2. Excavation
  const trenchWidth = Math.max(
    config.minTrenchWidth,
    diameterM * config.defaultTrenchWidthFactor
  );
  const excavationVolume = length * trenchWidth * avgDepth;
  const excItem = getExcavationItem(context.terrainType);
  if (excItem) {
    results.push({
      serviuCode: excItem.code,
      quantity: excavationVolume,
      unit: 'm3',
      category: 'excavacion',
      description: excItem.description,
      sourceEntityIds: [pipe.id],
      calculationDetails: `L=${length.toFixed(2)}m × A=${trenchWidth.toFixed(2)}m × H=${avgDepth.toFixed(2)}m`,
    });
  }

  // 3. Bedding
  const beddingWidth = Math.max(trenchWidth * 0.8, diameterM + 0.3);
  const beddingVolume = length * beddingWidth * config.defaultBeddingThickness;
  results.push({
    serviuCode: '220.2',
    quantity: beddingVolume,
    unit: 'm3',
    category: 'cama',
    description: 'Cama de arena para tuberías, e=0.15m',
    sourceEntityIds: [pipe.id],
    calculationDetails: `L=${length.toFixed(2)}m × A=${beddingWidth.toFixed(2)}m × e=${config.defaultBeddingThickness}m`,
  });

  // 4. Backfill
  const pipeVolume = length * Math.PI * Math.pow(diameterM / 2, 2);
  const backfillVolume = excavationVolume - beddingVolume - pipeVolume;
  if (backfillVolume > 0) {
    results.push({
      serviuCode: '210.1',
      quantity: backfillVolume,
      unit: 'm3',
      category: 'relleno',
      description: 'Relleno compactado con material seleccionado de la excavación',
      sourceEntityIds: [pipe.id],
      calculationDetails: `Vol. excavación - cama - tubería`,
    });
  }

  // 5. Excess removal
  const excessVolume = pipeVolume + beddingVolume * 0.1;
  results.push({
    serviuCode: '203.1',
    quantity: excessVolume,
    unit: 'm3',
    category: 'excavacion',
    description: 'Retiro y transporte de excedentes a botadero autorizado',
    sourceEntityIds: [pipe.id],
    calculationDetails: `Volumen tubería + esponjamiento`,
  });

  // 6. Hydraulic test
  results.push({
    serviuCode: '703.1',
    quantity: length,
    unit: 'm',
    category: 'varios',
    description: 'Prueba hidráulica de tuberías',
    sourceEntityIds: [pipe.id],
    calculationDetails: `Longitud a probar: ${length.toFixed(2)}m`,
  });

  return results;
}

// --- Storm Collector ---
function generateStormCollectorQuantities(
  collector: StormCollectorEntity,
  context: GeneratorContext
): QuantityResult[] {
  const results: QuantityResult[] = [];
  const { config } = context;

  const length = collector.length;
  const diameterMm = collector.diameter;
  const diameterM = diameterMm / 1000;

  // Calculate average depth
  const avgDepth = ((collector.invertStart || 0) + (collector.invertEnd || 0)) / 2 || 2.0;

  // 1. Collector pipe
  const isHA = collector.material === 'concrete';
  const pipeType = isHA ? 'storm_ha' : 'storm_pvc';
  const pipeItem = getPipeItem(diameterMm, pipeType);

  if (pipeItem) {
    results.push({
      serviuCode: pipeItem.code,
      quantity: length,
      unit: 'm',
      category: 'tuberia',
      description: pipeItem.description,
      sourceEntityIds: [collector.id],
      calculationDetails: `Longitud colector: ${length.toFixed(2)}m`,
    });
  }

  // 2. Excavation (larger trench for storm collectors)
  const trenchWidth = Math.max(
    config.minTrenchWidth + 0.2,
    diameterM * config.defaultTrenchWidthFactor
  );
  const excavationVolume = length * trenchWidth * avgDepth;
  const excItem = getExcavationItem(context.terrainType);
  if (excItem) {
    results.push({
      serviuCode: excItem.code,
      quantity: excavationVolume,
      unit: 'm3',
      category: 'excavacion',
      description: excItem.description,
      sourceEntityIds: [collector.id],
      calculationDetails: `L=${length.toFixed(2)}m × A=${trenchWidth.toFixed(2)}m × H=${avgDepth.toFixed(2)}m`,
    });
  }

  // 3. Bedding (thicker for storm collectors)
  const beddingThickness = config.defaultBeddingThickness * 1.5;
  const beddingWidth = Math.max(trenchWidth * 0.8, diameterM + 0.4);
  const beddingVolume = length * beddingWidth * beddingThickness;
  results.push({
    serviuCode: '220.3', // Gravel bedding for larger pipes
    quantity: beddingVolume,
    unit: 'm3',
    category: 'cama',
    description: 'Cama de grava para tuberías',
    sourceEntityIds: [collector.id],
    calculationDetails: `L=${length.toFixed(2)}m × A=${beddingWidth.toFixed(2)}m × e=${beddingThickness.toFixed(2)}m`,
  });

  // 4. Backfill
  const pipeVolume = length * Math.PI * Math.pow(diameterM / 2, 2);
  const backfillVolume = excavationVolume - beddingVolume - pipeVolume;
  if (backfillVolume > 0) {
    results.push({
      serviuCode: '210.1',
      quantity: backfillVolume,
      unit: 'm3',
      category: 'relleno',
      description: 'Relleno compactado con material seleccionado de la excavación',
      sourceEntityIds: [collector.id],
      calculationDetails: `Vol. excavación - cama - tubería`,
    });
  }

  // 5. Excess removal
  const excessVolume = pipeVolume + beddingVolume * 0.15;
  results.push({
    serviuCode: '203.1',
    quantity: excessVolume,
    unit: 'm3',
    category: 'excavacion',
    description: 'Retiro y transporte de excedentes a botadero autorizado',
    sourceEntityIds: [collector.id],
    calculationDetails: `Volumen tubería + esponjamiento`,
  });

  return results;
}

// --- Manhole ---
function generateManholeQuantities(
  manhole: ManholeEntity,
  context: GeneratorContext
): QuantityResult[] {
  const results: QuantityResult[] = [];

  const depth = manhole.depth || 2.0;
  const internalDiam = manhole.internalDiameter || 1.2;
  const wallThickness = 0.15; // Standard 15cm walls
  const externalDiam = internalDiam + 2 * wallThickness;

  // 1. Manhole structure
  const manholeItem = getManholeItem(depth, manhole.manholeType as 'A' | 'B');
  if (manholeItem) {
    results.push({
      serviuCode: manholeItem.code,
      quantity: 1,
      unit: 'un',
      category: 'camaras',
      description: manholeItem.description,
      sourceEntityIds: [manhole.id],
      calculationDetails: `Cámara ${manhole.manholeType}, H=${depth.toFixed(2)}m`,
    });
  }

  // 2. Excavation for chamber (with working space)
  const excDiameter = externalDiam + 0.6; // 30cm working space around
  const excavationVolume = Math.PI * Math.pow(excDiameter / 2, 2) * (depth + 0.2);
  const excItem = getExcavationItem(context.terrainType, true);
  if (excItem) {
    results.push({
      serviuCode: excItem.code,
      quantity: excavationVolume,
      unit: 'm3',
      category: 'excavacion',
      description: excItem.description,
      sourceEntityIds: [manhole.id],
      calculationDetails: `Ø exc.=${excDiameter.toFixed(2)}m × H=${(depth + 0.2).toFixed(2)}m`,
    });
  }

  // 3. Cover (tapa y cerco)
  results.push({
    serviuCode: '404.1',
    quantity: 1,
    unit: 'un',
    category: 'camaras',
    description: 'Tapa y cerco de fierro fundido para cámara, D400',
    sourceEntityIds: [manhole.id],
    calculationDetails: `Tapa ${manhole.coverClass || 'D400'}`,
  });

  // 4. Watertightness test
  results.push({
    serviuCode: '703.2',
    quantity: 1,
    unit: 'un',
    category: 'varios',
    description: 'Prueba de estanqueidad cámaras',
    sourceEntityIds: [manhole.id],
    calculationDetails: `Prueba cámara ${manhole.id}`,
  });

  return results;
}

// --- Storm Inlet ---
function generateStormInletQuantities(
  inlet: StormInletEntity,
  context: GeneratorContext
): QuantityResult[] {
  const results: QuantityResult[] = [];

  // Inlet structure
  const inletCode = inlet.inletType === 'S2' ? '502.2' : '502.1';
  const inletItem = getServiuItem(inletCode);
  if (inletItem) {
    results.push({
      serviuCode: inletCode,
      quantity: 1,
      unit: 'un',
      category: 'sumideros',
      description: inletItem.description,
      sourceEntityIds: [inlet.id],
      calculationDetails: `Sumidero tipo ${inlet.inletType}`,
    });
  }

  // Excavation for inlet
  const dims = inlet.dimensions || { length: 1.0, width: 0.5, depth: 0.8 };
  const excVolume = (dims.length + 0.4) * (dims.width + 0.4) * (dims.depth + 0.2);
  const excItem = getExcavationItem(context.terrainType, true);
  if (excItem) {
    results.push({
      serviuCode: excItem.code,
      quantity: excVolume,
      unit: 'm3',
      category: 'excavacion',
      description: excItem.description,
      sourceEntityIds: [inlet.id],
      calculationDetails: `Excavación sumidero ${dims.length}×${dims.width}×${dims.depth}m`,
    });
  }

  return results;
}

// --- House Connection ---
function generateHouseConnectionQuantities(
  connection: HouseConnectionEntity,
  context: GeneratorContext
): QuantityResult[] {
  const results: QuantityResult[] = [];
  const { config } = context;

  // House connection (UD)
  results.push({
    serviuCode: '403.1',
    quantity: 1,
    unit: 'un',
    category: 'conexiones',
    description: 'Unión domiciliaria de alcantarillado Ø110mm, completa',
    sourceEntityIds: [connection.id],
    calculationDetails: `UD Ø${connection.diameter}mm, L=${connection.length.toFixed(2)}m`,
  });

  // Excavation for connection
  const length = connection.length;
  const depth = 1.2; // Typical UD depth
  const trenchWidth = 0.6;
  const excavationVolume = length * trenchWidth * depth;

  const excItem = getExcavationItem(context.terrainType);
  if (excItem) {
    results.push({
      serviuCode: excItem.code,
      quantity: excavationVolume,
      unit: 'm3',
      category: 'excavacion',
      description: excItem.description,
      sourceEntityIds: [connection.id],
      calculationDetails: `L=${length.toFixed(2)}m × A=0.6m × H=1.2m`,
    });
  }

  return results;
}

// --- Water Valve ---
function generateWaterValveQuantities(
  valve: WaterValveEntity,
  context: GeneratorContext
): QuantityResult[] {
  const results: QuantityResult[] = [];

  const diameterMm = valve.diameter;
  let valveCode = '303.1'; // Default 75mm

  if (diameterMm >= 100) {
    valveCode = '303.2'; // 110mm+
  }

  const valveItem = getServiuItem(valveCode);
  if (valveItem) {
    results.push({
      serviuCode: valveCode,
      quantity: 1,
      unit: 'un',
      category: 'obras_civiles',
      description: valveItem.description,
      sourceEntityIds: [valve.id],
      calculationDetails: `Válvula ${valve.valveType} Ø${diameterMm}mm`,
    });
  }

  return results;
}

// --- Hydrant ---
function generateHydrantQuantities(
  hydrant: HydrantEntity,
  context: GeneratorContext
): QuantityResult[] {
  const results: QuantityResult[] = [];

  results.push({
    serviuCode: '304.1',
    quantity: 1,
    unit: 'un',
    category: 'obras_civiles',
    description: 'Grifo de incendio tipo tráfico completo',
    sourceEntityIds: [hydrant.id],
    calculationDetails: `Grifo Ø${hydrant.nominalDiameter}mm, ${hydrant.outlets} salidas`,
  });

  return results;
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Merge quantities with the same SERVIU code
 */
function mergeQuantities(
  quantities: QuantityResult[],
  context: GeneratorContext
): QuantityResult[] {
  const merged = new Map<string, QuantityResult>();

  for (const q of quantities) {
    const existing = merged.get(q.serviuCode);
    if (existing) {
      existing.quantity += q.quantity;
      existing.sourceEntityIds = [...existing.sourceEntityIds, ...q.sourceEntityIds];
      existing.calculationDetails = `${existing.calculationDetails}; ${q.calculationDetails}`;
    } else {
      merged.set(q.serviuCode, { ...q });
    }
  }

  // Sort by SERVIU code
  return Array.from(merged.values()).sort((a, b) => a.serviuCode.localeCompare(b.serviuCode));
}

/**
 * Calculate subtotals by category
 */
function calculateSubtotals(items: CubicacionItem[]): CubicacionSubtotal[] {
  const categoryTotals = new Map<CubicacionCategory, { total: number; count: number }>();

  for (const item of items) {
    const current = categoryTotals.get(item.category) || { total: 0, count: 0 };
    current.total += item.totalPrice;
    current.count += 1;
    categoryTotals.set(item.category, current);
  }

  const grandTotal = items.reduce((sum, item) => sum + item.totalPrice, 0);

  const subtotals: CubicacionSubtotal[] = [];
  const categoryOrder: CubicacionCategory[] = [
    'excavacion',
    'relleno',
    'cama',
    'tuberia',
    'camaras',
    'sumideros',
    'conexiones',
    'pavimentos',
    'obras_civiles',
    'varios',
  ];

  for (const category of categoryOrder) {
    const data = categoryTotals.get(category);
    if (data && data.total > 0) {
      subtotals.push({
        category,
        categoryLabel: CATEGORY_LABELS[category],
        total: data.total,
        percentage: grandTotal > 0 ? (data.total / grandTotal) * 100 : 0,
        itemCount: data.count,
      });
    }
  }

  return subtotals;
}

/**
 * Round quantity to specified decimals
 */
function roundQuantity(value: number, decimals: number): number {
  const factor = Math.pow(10, decimals);
  return Math.round(value * factor) / factor;
}

// ============================================================================
// Export Additional Utilities
// ============================================================================

/**
 * Recalculate totals for a cubicación with modified items
 */
export function recalculateTotals(cubicacion: Cubicacion): Cubicacion {
  const items = cubicacion.items.map((item) => ({
    ...item,
    totalPrice: Math.round(item.quantity * item.unitPrice),
  }));

  const subtotals = calculateSubtotals(items);
  const grandTotal = items.reduce((sum, item) => sum + item.totalPrice, 0);

  return {
    ...cubicacion,
    items,
    subtotals,
    grandTotal,
    updatedAt: new Date().toISOString(),
  };
}

/**
 * Add a manual item to cubicación
 */
export function addManualItem(
  cubicacion: Cubicacion,
  item: Omit<CubicacionItem, 'id' | 'totalPrice' | 'isManualOverride' | 'autoCalculated' | 'lastUpdated'>
): Cubicacion {
  const newItem: CubicacionItem = {
    ...item,
    id: `cub_item_manual_${Date.now()}`,
    totalPrice: Math.round(item.quantity * item.unitPrice),
    isManualOverride: true,
    autoCalculated: false,
    lastUpdated: new Date().toISOString(),
  };

  const updatedItems = [...cubicacion.items, newItem];
  return recalculateTotals({ ...cubicacion, items: updatedItems });
}

/**
 * Update an existing item
 */
export function updateItem(
  cubicacion: Cubicacion,
  itemId: string,
  updates: Partial<Pick<CubicacionItem, 'quantity' | 'unitPrice' | 'notes'>>
): Cubicacion {
  const items = cubicacion.items.map((item) => {
    if (item.id === itemId) {
      const updated = { ...item, ...updates };
      return {
        ...updated,
        totalPrice: Math.round(updated.quantity * updated.unitPrice),
        isManualOverride: true,
        lastUpdated: new Date().toISOString(),
      };
    }
    return item;
  });

  return recalculateTotals({ ...cubicacion, items });
}

/**
 * Remove an item from cubicación
 */
export function removeItem(cubicacion: Cubicacion, itemId: string): Cubicacion {
  const items = cubicacion.items.filter((item) => item.id !== itemId);
  return recalculateTotals({ ...cubicacion, items });
}
